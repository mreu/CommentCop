// code is taken from here: https://github.com/code-cracker/code-cracker/blob/90184774d2506d7c38e2578126d3512c93ae6149/src/Common/CodeCracker.Common/Extensions/GeneratedCodeAnalysisExtensions.cs

namespace CodeCracker
{
    using System;
    using System.Collections.Generic;
    using System.Linq;
    using System.Text.RegularExpressions;
    using Microsoft.CodeAnalysis;
    using Microsoft.CodeAnalysis.CSharp;
    using Microsoft.CodeAnalysis.CSharp.Syntax;
    using Microsoft.CodeAnalysis.Diagnostics;

    public static class GeneratedCodeAnalysisExtensions
    {
        public static bool IsGenerated(this SyntaxNodeAnalysisContext context) => (context.SemanticModel?.SyntaxTree?.IsGenerated() ?? false) || (context.Node?.IsGenerated() ?? false);

        public static bool IsGenerated(this SyntaxTreeAnalysisContext context) => context.Tree?.IsGenerated() ?? false;

        public static bool IsGenerated(this SymbolAnalysisContext context)
        {
            if (context.Symbol == null)
            {
                return false;
            }

            foreach (var syntaxReference in context.Symbol.DeclaringSyntaxReferences)
            {
                if (syntaxReference.SyntaxTree.IsGenerated())
                {
                    return true;
                }

                var root = syntaxReference.SyntaxTree.GetRoot();
                var node = root?.FindNode(syntaxReference.Span);
                if (node.IsGenerated())
                {
                    return true;
                }
            }

            return false;
        }

        public static bool IsGenerated(this SyntaxNode node) => node.HasAttributeOnAncestorOrSelf("DebuggerNonUserCode", "GeneratedCode");

        public static bool IsGenerated(this SyntaxTree tree) => (tree.FilePath?.IsOnGeneratedFile() ?? false) || tree.HasAutoGeneratedComment();

        public static bool HasAutoGeneratedComment(this SyntaxTree tree)
        {
            var root = tree.GetRoot();
            if (root == null)
            {
                return false;
            }

            var isCSharp = root is CompilationUnitSyntax;
            var firstToken = root.GetFirstToken();
            SyntaxTriviaList trivia;
            if (firstToken == default(SyntaxToken))
            {
                var token = isCSharp
                    ? ((CompilationUnitSyntax)root).EndOfFileToken
                    : ((Microsoft.CodeAnalysis.VisualBasic.Syntax.CompilationUnitSyntax)root).EndOfFileToken;
                if (!token.HasLeadingTrivia)
                {
                    return false;
                }

                trivia = token.LeadingTrivia;
            }
            else
            {
                if (!firstToken.HasLeadingTrivia)
                {
                    return false;
                }

                trivia = firstToken.LeadingTrivia;
            }

            if (isCSharp)
            {
                var commentLines = trivia.Where(t => t.IsKind(SyntaxKind.SingleLineCommentTrivia)).Take(2).ToList();
                if (commentLines.Count != 2)
                {
                    return false;
                }

                return commentLines[1].ToString() == "// <auto-generated>";
            }
            else
            {
                var commentLines = trivia.Where(t => t.IsKind(Microsoft.CodeAnalysis.VisualBasic.SyntaxKind.CommentTrivia)).Take(2).ToList();
                if (commentLines.Count != 2)
                {
                    return false;
                }

                return commentLines[1].ToString() == "' <auto-generated>";
            }
        }

        public static bool IsOnGeneratedFile(this string filePath) =>
            Regex.IsMatch(filePath, @"(\\service|\\TemporaryGeneratedFile_.*|\\assemblyinfo|\\assemblyattributes|\.(g\.i|g|designer|generated|assemblyattributes))\.(cs|vb)$", RegexOptions.IgnoreCase);

        public static bool HasAttributeOnAncestorOrSelf(this SyntaxNode node, string attributeName)
        {
            var csharpNode = node as CSharpSyntaxNode;
            if (csharpNode != null)
            {
                return csharpNode.HasAttributeOnAncestorOrSelf(attributeName);
            }

            return false;
        }

        public static bool HasAttributeOnAncestorOrSelf(this SyntaxNode node, params string[] attributeNames)
        {
            var csharpNode = node as CSharpSyntaxNode;
            if (csharpNode != null)
            {
                foreach (var attributeName in attributeNames)
                {
                    if (csharpNode.HasAttributeOnAncestorOrSelf(attributeName))
                    {
                        return true;
                    }
                }
            }

            return false;
        }

        public static bool HasAttributeOnAncestorOrSelf(this CSharpSyntaxNode node, string attributeName)
        {
            var parentMethod = (BaseMethodDeclarationSyntax)node.FirstAncestorOrSelfOfType(typeof(MethodDeclarationSyntax), typeof(ConstructorDeclarationSyntax));
            if (parentMethod?.AttributeLists.HasAttribute(attributeName) ?? false)
            {
                return true;
            }

            var type = (TypeDeclarationSyntax)node.FirstAncestorOrSelfOfType(typeof(ClassDeclarationSyntax), typeof(StructDeclarationSyntax));
            while (type != null)
            {
                if (type.AttributeLists.HasAttribute(attributeName))
                {
                    return true;
                }

                type = (TypeDeclarationSyntax)type.FirstAncestorOfType(typeof(ClassDeclarationSyntax), typeof(StructDeclarationSyntax));
            }

            var property = node.FirstAncestorOrSelfOfType<PropertyDeclarationSyntax>();
            if (property?.AttributeLists.HasAttribute(attributeName) ?? false)
            {
                return true;
            }

            var accessor = node.FirstAncestorOrSelfOfType<AccessorDeclarationSyntax>();
            if (accessor?.AttributeLists.HasAttribute(attributeName) ?? false)
            {
                return true;
            }

            var anInterface = node.FirstAncestorOrSelfOfType<InterfaceDeclarationSyntax>();
            if (anInterface?.AttributeLists.HasAttribute(attributeName) ?? false)
            {
                return true;
            }

            var anEvent = node.FirstAncestorOrSelfOfType<EventDeclarationSyntax>();
            if (anEvent?.AttributeLists.HasAttribute(attributeName) ?? false)
            {
                return true;
            }

            var anEnum = node.FirstAncestorOrSelfOfType<EnumDeclarationSyntax>();
            if (anEnum?.AttributeLists.HasAttribute(attributeName) ?? false)
            {
                return true;
            }

            var field = node.FirstAncestorOrSelfOfType<FieldDeclarationSyntax>();
            if (field?.AttributeLists.HasAttribute(attributeName) ?? false)
            {
                return true;
            }

            var eventField = node.FirstAncestorOrSelfOfType<EventFieldDeclarationSyntax>();
            if (eventField?.AttributeLists.HasAttribute(attributeName) ?? false)
            {
                return true;
            }

            var parameter = node as ParameterSyntax;
            if (parameter?.AttributeLists.HasAttribute(attributeName) ?? false)
            {
                return true;
            }

            var aDelegate = node as DelegateDeclarationSyntax;
            if (aDelegate?.AttributeLists.HasAttribute(attributeName) ?? false)
            {
                return true;
            }

            return false;
        }

        public static StatementSyntax FirstAncestorOrSelfThatIsAStatement(this SyntaxNode node)
        {
            var currentNode = node;
            while (true)
            {
                if (currentNode == null)
                {
                    break;
                }

                if (currentNode.IsAnyKind(
                    SyntaxKind.Block,
                    SyntaxKind.BreakStatement,
                    SyntaxKind.CheckedStatement,
                    SyntaxKind.ContinueStatement,
                    SyntaxKind.DoStatement,
                    SyntaxKind.EmptyStatement,
                    SyntaxKind.ExpressionStatement,
                    SyntaxKind.FixedKeyword,
                    SyntaxKind.ForEachKeyword,
                    SyntaxKind.ForStatement,
                    SyntaxKind.GotoStatement,
                    SyntaxKind.IfStatement,
                    SyntaxKind.LabeledStatement,
                    SyntaxKind.LocalDeclarationStatement,
                    SyntaxKind.LockStatement,
                    SyntaxKind.ReturnStatement,
                    SyntaxKind.SwitchStatement,
                    SyntaxKind.ThrowStatement,
                    SyntaxKind.TryStatement,
                    SyntaxKind.UnsafeStatement,
                    SyntaxKind.UsingStatement,
                    SyntaxKind.WhileStatement,
                    SyntaxKind.YieldBreakStatement,
                    SyntaxKind.YieldReturnStatement))
                {
                    return (StatementSyntax)currentNode;
                }

                currentNode = currentNode.Parent;
            }

            return null;
        }

        public static T FirstAncestorOrSelfOfType<T>(this SyntaxNode node)
            where T : SyntaxNode
            => (T)node.FirstAncestorOrSelfOfType(typeof(T));

        public static SyntaxNode FirstAncestorOrSelfOfType(this SyntaxNode node, params Type[] types)
        {
            var currentNode = node;
            while (true)
            {
                if (currentNode == null)
                {
                    break;
                }

                foreach (var type in types)
                {
                    if (currentNode.GetType() == type)
                    {
                        return currentNode;
                    }
                }

                currentNode = currentNode.Parent;
            }

            return null;
        }

        public static T FirstAncestorOfType<T>(this SyntaxNode node)
            where T : SyntaxNode
            =>
            (T)node.FirstAncestorOfType(typeof(T));

        public static bool HasAttribute(this SyntaxList<AttributeListSyntax> attributeLists, string attributeName) =>
              attributeLists.SelectMany(a => a.Attributes).Any(a => a.Name.ToString().EndsWith(attributeName, StringComparison.OrdinalIgnoreCase));

        public static NameSyntax ToNameSyntax(this INamespaceSymbol namespaceSymbol) =>
            ToNameSyntax(namespaceSymbol.ToDisplayString().Split('.'));

        private static NameSyntax ToNameSyntax(IEnumerable<string> names)
        {
            var count = names.Count();
            if (count == 1)
            {
                return SyntaxFactory.IdentifierName(names.First());
            }

            return SyntaxFactory.QualifiedName(
                ToNameSyntax(names.Take(count - 1)),
                ToNameSyntax(names.Skip(count - 1)) as IdentifierNameSyntax
            );
        }

        public static SyntaxNode FirstAncestorOfType(this SyntaxNode node, params Type[] types)
        {
            var currentNode = node;
            while (true)
            {
                var parent = currentNode.Parent;
                if (parent == null)
                {
                    break;
                }

                foreach (var type in types)
                {
                    if (parent.GetType() == type)
                    {
                        return parent;
                    }
                }

                currentNode = parent;
            }

            return null;
        }

        public static IList<IMethodSymbol> GetAllMethodsIncludingFromInnerTypes(this INamedTypeSymbol typeSymbol)
        {
            var methods = typeSymbol.GetMembers().OfType<IMethodSymbol>().ToList();
            var innerTypes = typeSymbol.GetMembers().OfType<INamedTypeSymbol>();
            foreach (var innerType in innerTypes)
            {
                methods.AddRange(innerType.GetAllMethodsIncludingFromInnerTypes());
            }

            return methods;
        }

        public static IEnumerable<INamedTypeSymbol> AllBaseTypesAndSelf(this INamedTypeSymbol typeSymbol)
        {
            yield return typeSymbol;
            foreach (var b in AllBaseTypes(typeSymbol))
            {
                yield return b;
            }
        }

        public static IEnumerable<INamedTypeSymbol> AllBaseTypes(this INamedTypeSymbol typeSymbol)
        {
            while (typeSymbol.BaseType != null)
            {
                yield return typeSymbol.BaseType;
                typeSymbol = typeSymbol.BaseType;
            }
        }

        public static bool IsAnyKind(this SyntaxNode node, params SyntaxKind[] kinds)
        {
            foreach (var kind in kinds)
            {
                if (node.IsKind(kind))
                {
                    return true;
                }
            }

            return false;
        }

        public static bool IsAnyKind(this SymbolDisplayPart displayPart, params SymbolDisplayPartKind[] kinds)
        {
            foreach (var kind in kinds)
            {
                if (displayPart.Kind == kind)
                {
                    return true;
                }
            }

            return false;
        }
    }
}
